{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f5\fswiss\fcharset0\fprq2{\*\panose 00000000000000000000}Helvetica{\*\falt Arial};}
{\f14\fnil\fcharset2\fprq2{\*\panose 05000000000000000000}Wingdings;}{\f16\fnil\fcharset77\fprq2{\*\panose 00000000000000000000}Zapf Dingbats{\*\falt Monotype Sorts};}{\f43\froman\fcharset238\fprq2 Times New Roman CE;}
{\f44\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f46\froman\fcharset161\fprq2 Times New Roman Greek;}{\f47\froman\fcharset162\fprq2 Times New Roman Tur;}{\f48\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f49\fswiss\fcharset238\fprq2 Arial CE;}
{\f50\fswiss\fcharset204\fprq2 Arial Cyr;}{\f52\fswiss\fcharset161\fprq2 Arial Greek;}{\f53\fswiss\fcharset162\fprq2 Arial Tur;}{\f54\fswiss\fcharset186\fprq2 Arial Baltic;}{\f55\fmodern\fcharset238\fprq1 Courier New CE;}
{\f56\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f58\fmodern\fcharset161\fprq1 Courier New Greek;}{\f59\fmodern\fcharset162\fprq1 Courier New Tur;}{\f60\fmodern\fcharset186\fprq1 Courier New Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;
\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;
\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}}{\*\listtable{\list\listtemplateid-1\listsimple{\listlevel\levelnfc0
\leveljc0\levelfollow0\levelstartat0\levelspace0\levelindent0{\leveltext\'01*;}{\levelnumbers;}}{\listname ;}\listid-2}}{\*\listoverridetable{\listoverride\listid-2\listoverridecount1{\lfolevel\listoverrideformat{\listlevel\levelnfc23\leveljc0
\levelfollow0\levelstartat0\levelold\levelspace0\levelindent360{\leveltext\'01\u-3913 ?;}{\levelnumbers;}\f3\fbias0 }}\ls1}}{\info{\title MdEdit Basics}{\author diane lowery}{\operator Marco Cant\'f9}{\creatim\yr1999\mo9\dy27\hr17\min12}
{\revtim\yr1999\mo9\dy27\hr17\min12}{\version2}{\edmins1}{\nofpages11}{\nofwords3006}{\nofchars17137}{\*\company Sybex Inc.}{\nofcharsws0}{\vern113}}\widowctrl\ftnbj\aenddoc\hyphcaps0\viewkind4\viewscale100 \fet0\sectd \linex0\sectdefaultcl {\*\pnseclvl1
\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc\nowidctlpar\adjustright \fs20\cgrid {\b\f1\fs36\cf6\cgrid0 MdEdit Basics
\par }\pard \nowidctlpar\adjustright {\b\f1\cf6\cgrid0 An introduction to the basic features of the MdEdit example, discussed in Chapter 7 of the book "Mastering Delphi 5". Written and copyrighted by Marco Cant\'f9.}{\b\f1\cgrid0 
\par }{\fs22\cgrid0 
\par This document explains how 
you create a simple editor based on the RichEdit control, using Delphi 5. The program has a menu and implements a number of features, including a complete scheme for opening and saving the text files. In fact, we want to be able to ask the user to save an
y modified file before opening a new one, to avoid losing any changes. Sounds like a professional application, doesn't it?
\par 
\par }{\b\f1\fs28\cgrid0 Menu and Actions
\par }{\fs22\cgrid0 
\par First of all, we need to build the menu, following the standard. The main menu starts with two standard pull-down m
enus, File and Edit, with the typical menu items. Then there are two specific pull-down menus, Font and Paragraph, with menu items to set the text font and alignment. The last two pull-down menus, Options and Help, are }{\i\fs22\cgrid0 almost }{
\fs22\cgrid0 standard: their names ar
e standard, but their menu items are not. The Options menu has commands to change the background color and to count the characters, and the Help menu has only the About menu item. Here is the structure of the menu, extracted from the main form DFM file:

\par 
\par }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  MainMenu: TMainMenu
\par   Images = Images
\par   }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  File1: TMenuItem
\par     Caption = }{\i\f2\fs18\cgrid0 '&File'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  New1: TMenuItem
\par       Action = acNew
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  N1: TMenuItem
\par       Caption = }{\i\f2\fs18\cgrid0 '-'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  Open1: TMenuItem
\par       Action = acOpen
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  Save1: TMenuItem
\par       Action = acSave
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  Saveas1: TMenuItem
\par       Action = acSaveas
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  N2: TMenuItem
\par       Caption = }{\i\f2\fs18\cgrid0 '-'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  Print1: TMenuItem
\par       Action = acPrint
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  N3: TMenuItem
\par       Caption = }{\i\f2\fs18\cgrid0 '-'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object }{\f2\fs18\cgrid0 Exit1: TMenuItem
\par       Action = acExit1
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  Edit1: TMenuItem
\par     Caption = }{\i\f2\fs18\cgrid0 '&Edit'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 object }{\f2\fs18\cgrid0 Undo1: TMenuItem
\par       Action = acUndo
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  N6: TMenuItem
\par       Caption = }{\i\f2\fs18\cgrid0 '-'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 end
\par     object }{\f2\fs18\cgrid0 Cut2: TMenuItem
\par       Action = acCut
\par     }{\b\f2\fs18\cgrid0 end
\par     object }{\f2\fs18\cgrid0 Copy1: TMenuItem
\par       Action = acCopy
\par     }{\b\f2\fs18\cgrid0 end
\par     object }{\f2\fs18\cgrid0 Paste1: TMenuItem
\par       Action = acPaste
\par }{\b\f2\fs18\cgrid0     end
\par   end
\par   object }{\f2\fs18\cgrid0 Font1: TMenuItem
\par     Caption = }{\i\f2\fs18\cgrid0 '&Font'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  Bold1: TMenuItem
\par       Action = acBold
\par     }{\b\f2\fs18\cgrid0 end
\par     object }{\f2\fs18\cgrid0 Italic1: TMenuItem
\par       Action = acItalic
\par     }{\b\f2\fs18\cgrid0 end
\par     object }{\f2\fs18\cgrid0 N5: TMenuItem
\par       Caption = }{\i\f2\fs18\cgrid0 '-'}{\f2\fs18\cgrid0 
\par }{\b\f2\fs18\cgrid0     end
\par     object }{\f2\fs18\cgrid0 More1: TMenuItem
\par       Action = acFont
\par }{\b\f2\fs18\cgrid0     end
\par   end
\par   object }{\f2\fs18\cgrid0 Paragraph1: TMenuItem
\par     Caption = }{\i\f2\fs18\cgrid0 '&Paragraph'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 object }{\f2\fs18\cgrid0 LeftAligned1: TMenuItem
\par       Action = acLeftAligned
\par       GroupIndex = 1
\par       RadioItem = True
\par }{\b\f2\fs18\cgrid0     end
\par     object }{\f2\fs18\cgrid0 RightAligned1: TMenuItem
\par       Action = acRightAligned
\par       GroupIndex = 1
\par       RadioItem = True
\par }{\b\f2\fs18\cgrid0     end
\par     object }{\f2\fs18\cgrid0 Centered1: TMenuItem
\par       Action = acCentered
\par       GroupIndex = 1
\par       RadioItem = True
\par }{\b\f2\fs18\cgrid0     end
\par   end
\par   object }{\f2\fs18\cgrid0 Options1: TMenuItem
\par     Caption = }{\i\f2\fs18\cgrid0 '&Options'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  BackColor1: TMenuItem
\par       Action = acBackColor
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  Countchars1: TMenuItem
\par       Action = acCountchars
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  Help1: TMenuItem
\par     Caption = }{\i\f2\fs18\cgrid0 '&Help'}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  About1: TMenuItem
\par       Action = acAbout
\par     }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 end
\par end
\par }{\fs22\cgrid0 
\par As you can see}{\fs22\cgrid0 ,}{\fs22\cgrid0 
 the menu is based on a number of actions. In this example, we want to implement all of the commands of the menu using actions, while the following versions (described in the book) add toolbars (with docking support), status bars, and many other user-inte
rface enhancements. }{\fs22\cgrid0 
\par }\pard \nowidctlpar\pnrnot1\adjustright {\fs22\cgrid0 
\par }\pard \nowidctlpar\adjustright {\fs22\cgrid0 This is the DFM code for the ActionList component of the application. I've listed }{\fs22\cgrid0 them }{\fs22\cgrid0 here because I have extra space (differently }{\fs22\cgrid0 from }{\fs22\cgrid0 
the printed book) and because this is an instructive example of the use of actions in Delphi:
\par 
\par }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  ActionList: TActionList
\par   Images = Images
\par   OnUpdate = ActionListUpdate
\par   }{\b\f2\fs18\cgrid0 object}{\f2\fs18\cgrid0  acNew: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'File'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 '&New'}{\f2\fs18\cgrid0 
\par     ImageIndex = 0
\par     ShortCut = 113
\par     OnExecute = NewExecute
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acOpen: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'File'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 '&Open...'
\par }{\f2\fs18\cgrid0     ImageIndex = 1
\par     ShortCut = 16463
\par     OnExecute = OpenExecute
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acSave: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'File'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 '&Save'
\par }{\f2\fs18\cgrid0     ImageIndex = 2
\par     ShortCut = 16467
\par     OnExecute = SaveExecute
\par     OnUpdate = acSaveUpdate
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acSaveas: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'File'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 'Save &as...'
\par }{\f2\fs18\cgrid0     OnExecute = SaveAsExecute
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acPrint: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'File'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 '&Print'
\par }{\f2\fs18\cgrid0     ImageIndex = 3
\par     ShortCut = 16464
\par     OnExecute = PrintExecute
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acExit1: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'File'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 'E&xit'}{\f2\fs18\cgrid0 
\par     ShortCut = 32883
\par     OnExecute = ExitExecute
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acCut: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Edit'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 'Cu&t'}{\f2\fs18\cgrid0 
\par     ImageIndex = 5
\par     ShortCut = 16472
\par     OnExecute = acCutExecute
\par     OnUpdate = acCutUpdate
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acCopy: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Edit'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 '&Copy'}{\f2\fs18\cgrid0 
\par     ImageIndex = 6
\par     ShortCut = 16451
\par     OnExecute = acCopyExecute
\par     OnUpdate = acCutUpdate
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acPaste: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Edit'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 '&Paste'
\par }{\f2\fs18\cgrid0     ImageIndex = 7
\par     ShortCut = 16470
\par     OnExecute = acPasteExecute
\par     OnUpdate = acPasteUpdate
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acBold: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Font'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 '&Bold'
\par }{\f2\fs18\cgrid0     ImageIndex = 8
\par     ShortCut = 16450
\par     OnExecute = BoldExecute
\par     OnUpdate = acBoldUpdate
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acItalic: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Font'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 '&Italic'}{\f2\fs18\cgrid0 
\par     ImageIndex = 9
\par     ShortCut = 16457
\par     OnExecute = ItalicExecute
\par     OnUpdate = acItalicUpdate
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acFont: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Font'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 '&Font...'
\par }{\f2\fs18\cgrid0     ImageIndex = 15
\par     OnExecute = FontExecute
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acLeftAligned: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Paragraph'}{\f2\fs18\cgrid0 
\par     Caption = }{\i\f2\fs18\cgrid0 '&Left'
\par }{\f2\fs18\cgrid0     Checked = True
\par     ImageIndex = 10
\par     ShortCut = 16460
\par     OnExecute = ChangeAlignment
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acCentered: TAction
\par     Tag = 2
\par     Category = }{\i\f2\fs18\cgrid0 'Paragraph'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 '&Centered'
\par }{\f2\fs18\cgrid0     ImageIndex = 11
\par     ShortCut = 16453
\par     OnExecute = ChangeAlignment
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acBackColor: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Options'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 '&Background Color...'
\par }{\f2\fs18\cgrid0     OnExecute = BackColorExecute
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acCountchars: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Options'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 '&Count chars...'
\par }{\f2\fs18\cgrid0     ImageIndex = 14
\par     OnExecute = CountCharsExecute
\par     OnUpdate = acCountcharsUpdate
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acAbout: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Help'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 '&About RichNote...'
\par }{\f2\fs18\cgrid0     OnExecute = AboutExecute
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acUndo: TAction
\par     Category = }{\i\f2\fs18\cgrid0 'Edit'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 '&Undo'
\par }{\f2\fs18\cgrid0     ImageIndex = 4
\par     ShortCut = 16474
\par     OnExecute = acUndoExecute
\par     OnUpdate = acUndoUpdate
\par }{\b\f2\fs18\cgrid0   end
\par   object }{\f2\fs18\cgrid0 acRightAligned: TAction
\par     Tag = 1
\par     Category = }{\i\f2\fs18\cgrid0 'Paragraph'
\par }{\f2\fs18\cgrid0     Caption = }{\i\f2\fs18\cgrid0 '&Right'
\par }{\f2\fs18\cgrid0     ImageIndex = 12
\par     ShortCut = 16466
\par     OnExecute = ChangeAlignment
\par }{\b\f2\fs18\cgrid0   end
\par end
\par }{\f2\fs18\cgrid0 
\par }{\b\f1\fs28\cgrid0 The File Menu
\par }{\fs22\cgrid0 
\par As I mentioned at the beginning, the most complex part of this program is implementing the commands of the File pull-down menu\emdash New, Open, Save, and Save As. In each case, we need to track whet
her the current file has changed, saving the file only if it has. We should prompt the user to save the file each time the program creates a new file, loads an existing one, or terminates.}{\fs22\cgrid0 
\par }\pard \nowidctlpar\pnrnot1\adjustright {\fs22\cgrid0 
\par }\pard \nowidctlpar\adjustright {\fs22\cgrid0 To accomplish this, I've added two fields and three methods to the class describing the form of the application:
\par }{\f2\fs18\cgrid0 
\par   }{\b\f2\fs18\cgrid0 private
\par }{\f2\fs18\cgrid0     FileName: string;
\par     Modified: Boolean;
\par   }{\b\f2\fs18\cgrid0 public
\par }{\f2\fs18\cgrid0     function SaveChanges: Boolean;
\par     function Save: Boolean;
\par     function SaveAs: Boolean;
\par }{\fs22\cgrid0 
\par The }{\f2\fs22\cgrid0 FileName}{\fs22\cgrid0  string and the }{\f2\fs22\cgrid0 Modified}{\fs22\cgrid0 
 flag are set when the form is created and changed when a new file is loaded or the user renames a file with the Save As command. These two flags are initialized when the form is first created:
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.FormCreate(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   FileName := }{\i\f2\fs18\cgrid0 ''}{\f2\fs18\cgrid0 ;
\par   Modified := False;
\par   Application.Title := Caption;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par The value of the flag changes as soon as you type new characters in the RichEdit control (in its }{\f2\fs22\cgrid0 OnChange}{\fs22\cgrid0  event handler):
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.RichEdit1Change(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   }{\i\f2\fs18\cgrid0 // enables save operations
\par }{\f2\fs18\cgrid0   Modified := True;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par When a new file is created, the program checks whether the text has been modified. If so, it calls the }{\f2\fs22\cgrid0 SaveChanges}{\fs22\cgrid0  function, which asks the user whether to save the changes, discard them, or skip the current operation:

\par }{\b\f2\fs18\cgrid0 
\par procedure}{\f2\fs18\cgrid0  TFormRichNote.New1Click(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 if not }{\f2\fs18\cgrid0 Modified }{\b\f2\fs18\cgrid0 or }{\f2\fs18\cgrid0 SaveChanges }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par   }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0     RichEdit1.Text := }{\i\f2\fs18\cgrid0 ''}{\f2\fs18\cgrid0 ;
\par     Modified := False;
\par     FileName := }{\i\f2\fs18\cgrid0 ''}{\f2\fs18\cgrid0 ;
\par     Caption := }{\i\f2\fs18\cgrid0 'RichNote - [Untitled]'}{\f2\fs18\cgrid0 ;
\par   }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par If the creation of a new file is confirmed, some simple operations take place, including using }{\i\fs22\cgrid0 'Untitled'}{\fs22\cgrid0  instead of the filename in the form's caption.
\par 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li360\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\ls1
\ls1\pnrauth1\pnrdate-1506163781\pnrstart0\pnrxst1\pnrxst0\pnrxst183\pnrxst240\pnrstop4\pnrstart1\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrstop9\pnrstart2\pnrnfc23\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0
\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrstop18\pnrstart3\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0
\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrstop36\adjustright {\b\f1\fs22\cgrid0 
Note: Short-Circuit Evaluation. }{\f1\fs22\cgrid0 The expression }{\f2\fs22\cgrid0 if not Modified or SaveChanges then}{\i\f1\fs22\cgrid0  }{\f1\fs22\cgrid0 
requires some explanation. By default, Pascal performs what is called "short-circuit evaluation" of complex conditional expressions. The idea is simple: if the expression }{\f2\fs22\cgrid0 not Modified}{\f1\fs22\cgrid0 
 is true, we are sure that the whole expression is going to be true, and we don't need to evaluate the second expression. In this particular case, the second expression is a function call, and the function is called only if }{\f2\fs22\cgrid0 Modified}{
\f1\fs22\cgrid0  is }{\f2\fs22\cgrid0 True}{\f1\fs22\cgrid0 . This behavior of }{\f2\fs22\cgrid0 or}{\f1\fs22\cgrid0  and }{\f2\fs22\cgrid0 and}{\f1\fs22\cgrid0  expressions can be changed by setting a Delphi compiler opt
ion called Complete Boolean Eval. You can find it on the Compiler page of the Project Options dialog box.
\par }\pard \nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\fs22\cgrid0 
\par The message box displayed by the }{\f2\fs22\cgrid0 SaveChanges}{\fs22\cgrid0  function has three options. If the user selects the Cancel button, the function returns }{\f2\fs22\cgrid0 False}{\fs22\cgrid0 . If the us
er selects No, nothing happens (the file is not saved)}{\fs22\cgrid0 ,}{\fs22\cgrid0  and the function returns }{\f2\fs22\cgrid0 True}{\fs22\cgrid0 
, to indicate that although we haven't actually saved the file, the requested operation (such as creating a new file) can be accomplished. If the user selects Yes, the file is saved and the function returns }{\f2\fs22\cgrid0 True}{\fs22\cgrid0 .}{
\fs22\cgrid0 
\par }\pard \nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot1\pndec }\pnrnot1\adjustright {\fs22\cgrid0 
\par }\pard \nowidctlpar{\*\pn \pnlvlcont\ilvl0\ls0\pnrnot0\pndec }\adjustright {\fs22\cgrid0 In the code of this function, notice in particular the call to the }{\f2\fs22\cgrid0 MessageDlg}{\fs22\cgrid0  function used as the value of a }{\f2\fs22\cgrid0 case}
{\fs22\cgrid0  statement:
\par }{\b\f2\fs18\cgrid0 
\par function }{\f2\fs18\cgrid0 TFormRichNote.SaveChanges: Boolean;
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 case}{\f2\fs18\cgrid0  MessageDlg (
\par     }{\i\f2\fs18\cgrid0 'The document '}{\f2\fs18\cgrid0  + filename + }{\i\f2\fs18\cgrid0 ' has changed.'}{\f2\fs18\cgrid0  +
\par     #13#13 + }{\i\f2\fs18\cgrid0 'Do you want to save the changes?'}{\f2\fs18\cgrid0 ,
\par     mtConfirmation, mbYesNoCancel, 0) }{\b\f2\fs18\cgrid0 of}{\f2\fs18\cgrid0 
\par   idYes:
\par }{\i\f2\fs18\cgrid0     // call Save and return its result
\par }{\f2\fs18\cgrid0     Result := Save;
\par   idNo:
\par }{\i\f2\fs18\cgrid0     // don't save and continue
\par }{\f2\fs18\cgrid0     Result := True;
\par   }{\b\f2\fs18\cgrid0 else}{\f2\fs18\cgrid0  }{\i\f2\fs18\cgrid0 // idCancel:}{\f2\fs18\cgrid0 
\par }{\i\f2\fs18\cgrid0     // don't save and abort operation
\par }{\f2\fs18\cgrid0     Result := False;
\par   }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par {\pntext\pard\plain\f3\fs22 \loch\af3\dbch\af0\hich\f3 \'b7\tab}}\pard \fi-360\li360\nowidctlpar{\*\pn \pnlvlblt\ilvl0\ls1\pnrnot0\pnf3\pnindent360 {\pntxtb \'b7}}\ls1
\ls1\pnrauth1\pnrdate-1506163781\pnrstart0\pnrxst1\pnrxst0\pnrxst183\pnrxst240\pnrstop4\pnrstart1\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrrgb0\pnrstop9\pnrstart2\pnrnfc23\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0
\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc1\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrnfc0\pnrstop18\pnrstart3\pnrpnbr1\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0
\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrpnbr0\pnrstop36\adjustright {\b\f1\fs22\cgrid0 Note}{\f1\fs22\cgrid0 
: In the MessageDlg call above, I've added explicit newline characters (}{\f2\fs22\cgrid0 #13}{\f1\fs22\cgrid0 ) to improve the readability of the output. As an alternative to using a numeric character constant, you can call }{\f2\fs22\cgrid0 Chr(13)}{
\f1\fs22\cgrid0 .}{\f5\fs24\cgrid0 
\par }\pard \nowidctlpar\adjustright {\fs22\cgrid0 
\par To actually save the file, another function is invoked: }{\f2\fs22\cgrid0 Save}{\fs22\cgrid0 . This method saves the file if it already has a proper filename or asks the user to enter a name, calling the }{\f2\fs22\cgrid0 SaveAs}{\fs22\cgrid0 
 functions. These are two more internal functions, not directly connected with menu items:
\par 
\par }{\b\f2\fs18\cgrid0 function}{\f2\fs18\cgrid0  TFormRichNote.Save: Boolean;
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 if}{\f2\fs18\cgrid0  Filename = }{\i\f2\fs18\cgrid0 ''}{\f2\fs18\cgrid0  }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par     Result := SaveAs }{\i\f2\fs18\cgrid0 // ask for a file name}{\f2\fs18\cgrid0 
\par }{\b\f2\fs18\cgrid0   else
\par   begin
\par }{\f2\fs18\cgrid0     RichEdit1.Lines.SaveToFile (FileName);
\par     Modified := False;
\par     Result := True;
\par }{\b\f2\fs18\cgrid0   end;
\par end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f2\fs18\cgrid0 function }{\f2\fs18\cgrid0 TFormRichNote.SaveAs: Boolean;
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   SaveDialog1.FileName := Filename;
\par   }{\b\f2\fs18\cgrid0 if}{\f2\fs18\cgrid0  SaveDialog1.Execute }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par   }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0     Filename := SaveDialog1.FileName;
\par     Save;
\par     Caption := }{\i\f2\fs18\cgrid0 'RichNote - '}{\f2\fs18\cgrid0  + Filename;
\par     Result := True;
\par   }{\b\f2\fs18\cgrid0 end
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 else
\par }{\f2\fs18\cgrid0     Result := False;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par I use two functions to perform the Save and SaveAs operations (and do not call the corresponding menu handler directly) because I need a way to 
report a request to cancel the operation from the user. To avoid code duplication, the handlers of the Save and SaveAs actions call the two functions too, although they ignore the return value:
\par }{\b\f2\fs18\cgrid0 
\par procedure}{\f2\fs18\cgrid0  TFormRichNote.SaveExecute(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 if}{\f2\fs18\cgrid0  Modified }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par     Save;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f2\fs18\cgrid0 procedure}{\f2\fs18\cgrid0  TFormRichNote.SaveAsExecute(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   SaveAs;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par Moreover, the }{\fs22\cgrid0 Save }{\fs22\cgrid0 action is enabled only if the file has not been modified, as indicated in the }{\f2\fs22\cgrid0 OnUpdate}{\fs22\cgrid0  event handler of the }{\f2\fs22\cgrid0 acSave}{\fs22\cgrid0  action:
\par }{\b\f2\fs18\cgrid0 
\par procedure}{\f2\fs18\cgrid0  TFormRichNote.acSaveUpdate(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   acSave.Enabled := Modified;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par Opening a file is much simpler. Before loading a new file, the program checks whether the current file has changed, asking the user to save it with the }{\f2\fs22\cgrid0 SaveChanges}{\fs22\cgrid0  function, as before. The }{\f2\fs22\cgrid0 OpenExecute}{
\fs22\cgrid0  method is based on the OpenDialog component, another default dialog box provided by Windows and supported by Delphi:
\par }{\b\f2\fs18\cgrid0 
\par procedure}{\f2\fs18\cgrid0  TFormRichNote.OpenExecute(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 if not }{\f2\fs18\cgrid0 Modified }{\b\f2\fs18\cgrid0 or }{\f2\fs18\cgrid0 SaveChanges }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 if }{\f2\fs18\cgrid0 OpenDialog1.Execute }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0       Filename := OpenDialog1.FileName;
\par       RichEdit1.Lines.LoadFromFile (FileName);
\par       Modified := False;
\par       Caption := }{\i\f2\fs18\cgrid0 'RichNote - '}{\f2\fs18\cgrid0  + FileName;
\par     }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par The only other detail related to file operations is that both the OpenDialog and SaveDialog components of the NotesForm have a particular value for their }{\f2\fs22\cgrid0 Filter}{\fs22\cgrid0  and }{\f2\fs22\cgrid0 DefaultExt}{\fs22\cgrid0 
 properties, as you can see in the following fragment from the textual description of the form:
\par }{\b\f2\fs18\cgrid0 
\par object }{\f2\fs18\cgrid0 OpenDialog1: TOpenDialog
\par   DefaultExt = }{\i\f2\fs18\cgrid0 'rtf'}{\f2\fs18\cgrid0 
\par   FileEditStyle = fsEdit
\par   Filter = }{\i\f2\fs18\cgrid0 'Rich Text File (*.rtf)|*.rtf|Any file (*.*)|*.*'}{\f2\fs18\cgrid0 
\par   Options = [ofHideReadOnly, ofPathMustExist,ofFileMustExist]
\par }{\b\f2\fs18\cgrid0 end
\par }{\fs22\cgrid0 
\par The string used for the }{\f2\fs22\cgrid0 Filter}{\fs22\cgrid0  property contains four pairs of substrings, separated by the }{\f2\fs22\cgrid0 |}{\fs22\cgrid0 
 symbol. Each pair has a description of the type of file that will appear in the File Open or File Save dialog box, and the filter to be applied to the files in the directory, such as }{\f2\fs22\cgrid0 *.RTF}{\fs22\cgrid0 . To set
 the filters in Delphi, you can simply invoke the editor of this property, which displays a list with two columns.}{\fs22\cgrid0 
\par }\pard \nowidctlpar\pnrnot1\adjustright {\fs22\cgrid0 
\par }\pard \nowidctlpar\adjustright {\fs22\cgrid0 The file-related methods above are also called from the }{\f2\fs22\cgrid0 FormCloseQuery}{\fs22\cgrid0  method (the handler of the }{\f2\fs22\cgrid0 OnCloseQuery}{\fs22\cgrid0  event), which is called each 
time the user tries to close the form, terminating the program. We can make this happen in various ways\emdash by double-clicking on the system menu icon, selecting the system menu's Close command, pressing the Alt+F4 keys, or calling the }{
\f2\fs22\cgrid0 Close}{\fs22\cgrid0  method in the code, as in the File }{\f14\fs22\cgrid0 \'d8}{\f16\fs22\cgrid0  }{\fs22\cgrid0 Exit menu command.}{\fs22\cgrid0 
\par }\pard \nowidctlpar\pnrnot1\adjustright {\fs22\cgrid0 
\par }\pard \nowidctlpar\adjustright {\fs22\cgrid0 In }{\f2\fs22\cgrid0 FormCloseQuery}{\fs22\cgrid0 , you can decide whether or not to actually close the application by setting the }{\f2\fs22\cgrid0 CanClose}{\fs22\cgrid0 
 parameter, which is passed by reference. Again, if the current file has been modified, we call the }{\f2\fs22\cgrid0 SaveChanges}{\fs22\cgrid0  function and use its return value. Again we can use the short-circuit evaluation technique:
\par }{\b\f2\fs18\cgrid0 
\par procedure}{\f2\fs18\cgrid0  TFormRichNote.FormCloseQuery(Sender: TObject;
\par   }{\b\f2\fs18\cgrid0 var }{\f2\fs18\cgrid0 CanClose: Boolean);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   CanClose := }{\b\f2\fs18\cgrid0 not }{\f2\fs18\cgrid0 Modified }{\b\f2\fs18\cgrid0 or }{\f2\fs18\cgrid0 SaveChanges;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par The last menu item of the File menu is the Print command. The RichEdit component includes print capabilities}{\fs22\cgrid0 ,}{\fs22\cgrid0  and they are very simple to use. Here is the code, which actually produces a very nice printout:
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.Print1Click(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   RichEdit1.Print (FileName);
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f1\fs28\cgrid0 The Edit Menu
\par }{\fs22\cgrid0 
\par The Edit menu performs standard operations with the clipboard, plus the Undo. Implementing this menu is simple, as the RichEdit component already provides full support for the requested actions:
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.acUndoExecute(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   RichEdit.Undo;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f2\fs18\cgrid0 procedure }{\f2\fs18\cgrid0 TFormRichNote.acCutExecute(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   RichEdit.CutToClipboard;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f2\fs18\cgrid0 procedure }{\f2\fs18\cgrid0 TFormRichNote.acCopyExecute(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   RichEdit.CopyToClipboard;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f2\fs18\cgrid0 procedure }{\f2\fs18\cgrid0 TFormRichNote.acPasteExecute(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   RichEdit.PasteFromClipboard;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par Also refreshing the user interface of the actions is quite simple, as you can ask the RichEdit component whether it has changes to undo, check if there is selected text to copy, and (with a low-level }{\f2\fs22\cgrid0 SendMessage}{\fs22\cgrid0 
 call) verify whether the current clipboard content can be pasted in the text:
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.acUndoUpdate(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   acUndo.Enabled := RichEdit.CanUndo;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f2\fs18\cgrid0 procedure }{\f2\fs18\cgrid0 TFormRichNote.acCutUpdate(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   acCut.Enabled := RichEdit.SelLength > 0;
\par   acCopy.Enabled := acCut.Enabled;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f2\fs18\cgrid0 procedure }{\f2\fs18\cgrid0 TFormRichNote.acPasteUpdate(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   acPaste.Enabled := SendMessage (
\par     RichEdit.Handle, em_CanPaste, 0, 0) <> 0;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f1\fs28\cgrid0 The Paragraph Menu
\par }{\fs22\cgrid0 
\par The code of the Paragraph menu is based on some properties the associated actions, particularly the value of the }{\f2\fs22\cgrid0 Tag}{\fs22\cgrid0  property. As you can see in the DFM li
stings presented earlier, the program uses radio menu items, by giving to the three items the same value for the }{\f2\fs22\cgrid0 GroupIndex}{\fs22\cgrid0  property and setting the }{\f2\fs22\cgrid0 RadioItem}{\fs22\cgrid0  property to }{\f2\fs22\cgrid0 
True}{\fs22\cgrid0 . }{\fs22\cgrid0 
\par }\pard \nowidctlpar\pnrnot1\adjustright {\fs22\cgrid0 
\par }\pard \nowidctlpar\adjustright {\fs22\cgrid0 The actions share the same }{\f2\fs22\cgrid0 ChangeAlignment}{\fs22\cgrid0  method for their }{\f2\fs22\cgrid0 OnExecute}{\fs22\cgrid0  events.
 Here is the code of the method, which is based on the correspondence between the }{\f2\fs22\cgrid0 Tag}{\fs22\cgrid0  and the order of the values of the }{\f2\fs22\cgrid0 TAlignment}{\fs22\cgrid0 
 enumeration. It is a trick, but it works. Here is the code:
\par 
\par }{\b\f2\fs18\cgrid0 procedure }{\f2\fs18\cgrid0 TFormRichNote.ChangeAlignment(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\i\f2\fs18\cgrid0   // change paragraph alignment using the TAlignment
\par   // value saved in the tag of the action
\par }{\f2\fs18\cgrid0   RichEdit.Paragraph.Alignment := TAlignment (
\par     (Sender }{\b\f2\fs18\cgrid0 as}{\f2\fs18\cgrid0  TAction).Tag);
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par This procedure sets the alignment of the current paragraph (the paragraph including the selected text or the editor cursor). As you can see, this code relies on some controlled typecasts, based on the }{\f2\fs22\cgrid0 as}{\fs22\cgrid0 
 keyword: this is what you have to do any time you want to write generic code (that is, to attach the same methods to events of different components). The status of the actions, instead, is refreshed by the }{\f2\fs22\cgrid0 OnUpdate}{\fs22\cgrid0 
 event of the action list (to avoid duplicating the code and executing it multiple times):
\par }{\b\f2\fs18\cgrid0 
\par procedure}{\f2\fs18\cgrid0  TFormRichNote.ActionListUpdate(Action: TBasicAction;
\par   }{\b\f2\fs18\cgrid0 var}{\f2\fs18\cgrid0  Handled: Boolean);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   }{\i\f2\fs18\cgrid0 // check the proper paragraph alignment
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 case }{\f2\fs18\cgrid0 RichEdit.Paragraph.Alignment }{\b\f2\fs18\cgrid0 of}{\f2\fs18\cgrid0 
\par     taLeftJustify: acLeftAligned.Checked := True;
\par     taRightJustify: acRightAligned.Checked := True;
\par     taCenter: acCentered.Checked := True;
\par   }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f1\fs28\cgrid0 The Font Menu
\par }{\fs22\cgrid0 
\par The Font pull-down menu has only two options, Bold and Italic, plus a More menu }{\fs22\cgrid0 item, }{\fs22\cgrid0 which fires the standard Windows font selection dialog box. The Bold and Italic actions handle the executio
n and updates in a very similar way. Here is one of the two sets of methods:
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.BoldExecute(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   }{\b\f2\fs18\cgrid0 with}{\f2\fs18\cgrid0  RichEdit.SelAttributes }{\b\f2\fs18\cgrid0 do}{\f2\fs18\cgrid0 
\par     }{\b\f2\fs18\cgrid0 if }{\f2\fs18\cgrid0 fsBold }{\b\f2\fs18\cgrid0 in}{\f2\fs18\cgrid0  Style }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par       Style := Style - [fsBold]
\par     }{\b\f2\fs18\cgrid0 else
\par }{\f2\fs18\cgrid0       Style := Style + [fsBold];
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f2\fs18\cgrid0 procedure }{\f2\fs18\cgrid0 TFormRichNote.acBoldUpdate(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   acBold.Checked := fsBold }{\b\f2\fs18\cgrid0 in}{\f2\fs18\cgrid0  RichEdit.SelAttributes.Style;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par Again, this code acts on the current selection (using the }{\f2\fs22\cgrid0 SelAttributes}{\fs22\cgrid0 
 property of the RichEdit1 component). The last item of this menu simply activates the Font dialog box. Notice that the font returned by this dialog box cannot be assigned directly to the }{\f2\fs22\cgrid0 SelAttributes}{\fs22\cgrid0 
 property; we need to call the }{\f2\fs22\cgrid0 Assign}{\fs22\cgrid0  method, instead:
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.FontExecute(Sender: TObject);;
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   FontDialog1.Font := RichEdit1.Font;
\par   }{\b\f2\fs18\cgrid0 if}{\f2\fs18\cgrid0  FontDialog1.Execute }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par     RichEdit1.SelAttributes.Assign (FontDialog1.Font);
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\b\f1\fs28\cgrid0 The Options Menu
\par }{\fs22\cgrid0 
\par The last pull-down menu of the RichNot2 example
 is the Options menu. This menu has two unrelated commands used to customize the user interface and to determine and display the length of the text. The first command displays a color selection dialog box, used to change the color of the background of the
 RichEdit component:
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.BackColorExecute(Sender: TObject);;
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   ColorDialog1.Color := RichEdit1.Color;
\par   }{\b\f2\fs18\cgrid0 if}{\f2\fs18\cgrid0  ColorDialog1.Execute }{\b\f2\fs18\cgrid0 then}{\f2\fs18\cgrid0 
\par     RichEdit1.Color := ColorDialog1.Color;
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par }{\fs22\cgrid0 
\par The other menu item activates a method to count the number of characters in the text and display the total in a message box. The core of the method is the call to the }{\f2\fs22\cgrid0 GetTextLen}{\fs22\cgrid0 
 function of the RichEdit control. The number is extracted and formatted into an output string:
\par }{\b\f2\fs18\cgrid0 
\par procedure }{\f2\fs18\cgrid0 TFormRichNote.Countchars1Click(Sender: TObject);
\par }{\b\f2\fs18\cgrid0 begin
\par }{\f2\fs18\cgrid0   MessageDlg (Format (
\par     }{\i\f2\fs18\cgrid0 'The text has %d characters'}{\f2\fs18\cgrid0 , [RichEdit1.GetTextLen]),
\par     mtInformation, [mbOK], 0);
\par }{\b\f2\fs18\cgrid0 end}{\f2\fs18\cgrid0 ;
\par 
\par }{\fs22\cgrid0 The final menu, Help, has only an About command, which displays a message to the user.
\par 
\par }{\b\f1\fs28\cgrid0 Conclusion
\par }{\fs22\cgrid0 
\par As mentioned at the beginning, this was a rather long and complex example, but its purpose was to show you the implementation of the menu commands of a real-world application. In particular, I explained in detail the File pull-down menu because this is so
mething you'll probably need to handle in any file-related application. As this was too long for inclusion in the printed "Mastering Delphi 5," I've decided to place it within the source code, instead of skipping it altogether.}{\fs22\cgrid0 
\par }\pard \nowidctlpar\pnrnot1\adjustright {\fs22\cgrid0 
\par }\pard \nowidctlpar\adjustright {\fs22\cgrid0 You can now get back to the book (mainly Chapter 7) to see how the example can be extended in a number of different ways.
\par }{\fs18\lang3081\cgrid0 
\par }}